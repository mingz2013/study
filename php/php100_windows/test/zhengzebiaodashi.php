<p style="color:red"><b>正则表达式</b>	<hr></p><p>	1.<br>		主要作用：分隔 匹配 查找 替换<br>		采集 分析网页 字符串 <br></p><p>	2.<br>		php中两个常用的正则函数<br>		preg_match(mode, string subject, array matches);	 以perl语言为基础<br>		ereg(mode, string subject, array regs);				以 POSIX基础 （Unix，Script）<br></p><p>	3.<br>		正则表达式中包括的元素<br>		1,原子(普通字符：a-z A-Z 0-9 ， 原子表，转义字符)<br>		2,元字符（有特殊功能的字符）<br>		3,模式修正符（系统内置部分字符i,m,S,U...）<br></p><p>	4.<br>		原子<br>		1	a-z A-Z 0-9 // 最常见的字符<br>		2	(abc) (skd) // 用圆括号包含起来的单元符号<br>		3	[abcs] [^abd]	// 用方括号包含起来的原子表，原子表中的 ^ 代表排除或相反地内容<br>		4	转义字符<br>			\d 包含所有字符[0-9]<br>			\B 除所有数字外[^0-9]<br>			\w 包含所有英文字符[a-zA-Z ,_ ,0-9]<br>			\W 除所有英文字符外[^a-zA-Z,_,0-9]<br>			\s 包含空白区域如回车 换行 分页 等。。。<br></p><hr><?	preg_match('#abc#','fdgdfkgfsndkbOBFabcfdgfjf',$arr);	print_r($arr);echo "<br>";	ereg('abc','fdgdfkgfsndkbOBFabcfdgfjf',$arr);	print_r($arr);echo "<br>";	echo "<br><br>";			$mode="/abc/";	$made="/(abc)/";	$mode="/[abc]/";	$mode="/[^abc]/";	$mode="/[0-9]/";	$mode="/\d/";	$mode="/\B/";		$str="dsgdfshgdhdfabcdfhj5345soafgfdfg";		if(preg_match($mode,$str,$arr))	{			echo "匹配成功";		print_r($arr);		echo "<br>";	}	else	{		echo "匹配不成功<br>";	}?><hr><p>	<b>正则表达式元字符</b><br>	*	匹配前一个内容的0次1次或多次	<br>	.	匹配前一个内容的0次1次或多次，但不包含回车 换行	<br>	+	匹配前一个内容的1次或多次	<br>	?	匹配前一个内容的0次或1次	<br>	|	选择匹配类似PHP中的 | （因为这个运算符是弱类型 导致前面最为整体匹配）	<br>	^	匹配字符串首部内容	<br>	S	匹配字符串尾部内容	<br>	\b 	匹配单词边界，边界可以是空格或者特殊符号	<br>	\B 	匹配除带单词以外内容	<br>	{m}	匹配前一个内容的重复次数为 M 次	<br>	{m,}	匹配前一个内容的重复次数大于等于M次	<br>	{m,n}	匹配前一个内容的重复次数M次到N次	<br>	()	合并整体分配，并放入内存，可使用 \1 \2 ....以此获取</p><p>	<b>模式修正符</b><br>	1.运算顺序<br>		遵循从左到右的运算规则<br>		优先级：<br>			()	圆括号因为是内存处理 所以最高<br>			* ? + {} 重复匹配内容 其次	<br>			^ $ \b 边界处理第三	<br>			|	条件处理第四<br>			最后按照运算顺序计算匹配<br>				2,模式修正符<br>		使用在正则表达式之外<br>		用法：    /正则/U				<br>		i 正则内容在匹配时候不区分大小写(默认是区分的)<br>		m 在匹配首内容或者尾内容时候采用多行识别匹配<br>		S 将转义回车取消是为单行匹配如.匹配的时候<br>		x 忽略正则中的空白<br>		A 强制从头开始匹配<br>		D 强制$匹配尾部无任何内容\n 	<br>		U 禁止贪婪匹配 只跟踪到最近的一个匹配符并结束 ,常用在采集程序上的正则表达式<br></p><p>	功能应用：<br>		1.匹配功能<br>			preg_match_all(string pattem, string subject, array matches[,int flags]);	全部匹配函数<br>		2.替换功能<br>			preg_replace(mixed pattem, mixed replacement, mixed subject[,int limit]);	正则替换函数<br>			类似 str_replace 字符串替换，但功能要强于它<br>		3.分割功能<br>			preg_split(string pattem,string subject[,int limit[ ,int flags]]); 	正则分割<br></p>